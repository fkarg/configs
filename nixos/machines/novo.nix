
# Do not modify this file!  It was generated by ‘nixos-generate-config’
# and may be overwritten by future invocations.  Please make changes
# to /etc/nixos/configuration.nix instead.
{ config, lib, pkgs, modulesPath, ... }:

{
  imports =
    [ (modulesPath + "/installer/scan/not-detected.nix")
    ];

  boot.initrd.availableKernelModules = [ "nvme" "xhci_pci" "ahci" "usbhid" "usb_storage" "sd_mod" ];
  boot.initrd.kernelModules = [ ];
  # boot.kernelParams = [ "mem_sleep_default=deep" "nvme.noacpi=1" "mitigations=off" "fsck.mode=force" "fsck.repair=yes" "i915.enable_psr=1"];
  boot.kernelModules = [ "kvm-amd" ];
  boot.extraModulePackages = [ ];

  powerManagement.powertop.enable = true;

  fileSystems."/" =
    { device = "/dev/disk/by-uuid/876058bd-f3aa-49e8-9853-d3fc578cef78";
      fsType = "ext4";
    };

  boot.initrd.luks.devices."crypted".device = "/dev/disk/by-uuid/c775ece8-aa98-4880-a4f6-12c9c086655d";

  fileSystems."/nix" =
    { device = "/dev/disk/by-uuid/cdaa59c0-e247-449c-bca1-fa52e2743479";
      fsType = "ext4";
    };

  fileSystems."/boot" =
    { device = "/dev/disk/by-uuid/7E75-51AD";
      fsType = "vfat";
    };

  swapDevices = [ ];

  # Use the systemd-boot EFI boot loader.
  boot.loader.systemd-boot.enable = true;
  boot.loader.efi.canTouchEfiVariables = true;

  # networking
  networking.hostName = "novo";
  # networking.wireless.enable = true;  # Enables wireless support via wpa_supplicant.
  networking.networkmanager.enable = true;

  # The global useDHCP flag is deprecated, therefore explicitly set to false here.
  # Per-interface useDHCP will be mandatory in the future, so this generated config
  # replicates the default behaviour.

  # virtualisation.lxd.enable = true;
  virtualisation.docker.enable = true;

  # enable touchpad support
  services.xserver.libinput = {
    enable = true;
    touchpad.disableWhileTyping = true;
  };

  # enable fingerprent sensor
  services.fprintd.enable = true;

  # bluetooth
  # $ bluetoothctl
  # [bluetooth] # power on
  # [bluetooth] # agent on
  # [bluetooth] # default-agent
  # [bluetooth] # scan on
  # ...put device in pairing mode and wait [hex-address] to appear here...
  # [bluetooth] # pair [hex-address]
  # [bluetooth] # connect [hex-address]
  hardware.bluetooth.enable = true;
  services.blueman.enable = true;

  hardware.acpilight.enable = true;
 


  # Enables DHCP on each ethernet and wireless interface. In case of scripted networking
  # (the default) this is the recommended approach. When using systemd-networkd it's
  # still possible to use this option, but it's recommended to use it in conjunction
  # with explicit per-interface declarations with `networking.interfaces.<interface>.useDHCP`.
  networking.useDHCP = lib.mkDefault true;
  networking.interfaces.wlp1s0.useDHCP = lib.mkDefault true;

  nixpkgs.hostPlatform = lib.mkDefault "x86_64-linux";
  hardware.cpu.amd.updateMicrocode = lib.mkDefault config.hardware.enableRedistributableFirmware;

  environment.systemPackages = with pkgs; [
    slack
    (vscode-with-extensions.override {
      vscodeExtensions = with vscode-extensions; [
        ms-python.python
        vscodevim.vim
        asvetliakov.vscode-neovim
        ms-vscode-remote.remote-ssh
        ms-ceintl.vscode-language-pack-de
        matklad.rust-analyzer
        matangover.mypy
        github.copilot
        bbenoist.nix
        ms-azuretools.vscode-docker

      # ] ++ pkgs.vscode-utils.extensionsFromVscodeMarketplace [
      #   {
      #     name = "remote-ssh-edit";
      #     publisher = "ms-vscode-remote";
      #     version = "0.47.2";
      #     sha256 = "1hp6gjh4xp2m1xlm1jsdzxw9d8frkiidhph6nvl24d0h8z34w49g";
      #   }
      ];
    })
  ];
}
